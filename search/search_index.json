{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Rickypedia","text":"<p>Full documentation for any modding resource I made.</p>"},{"location":"#content","title":"Content","text":"<pre><code>Menu Reimagined\n</code></pre>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"Menu%20Reimagined/","title":"BETA 0.1","text":"<p>Welcome to this solo project that aims to reimplement the menu in a certain degree, allowing customizations such as:</p> <p>ANIMATED Portraits, with option for custom Idle animation/s and sfx, character custom requeriments to play as them (tokens, etc, still not implemented completely), Menu Code, custom callbacks and MORE.</p>"},{"location":"Menu%20Reimagined/#how-menu-is-created","title":"How Menu is created","text":"<p>First, we make a table with all the vanilla characters like this - OldMenu     - Normal     - Tainted We remove the hidden and locked ones</p> <p>Now comes the tricky part, the modded characters...</p> <p>From the vanilla Character max Id + 1, we repeat untill the Id is nil, therefore making a new table with all the moded characters like this. - NewMenu     - Normal     - Tainted</p> <p>After this, we run the custom callback \"MenuReimagined_GetCharacterMenu\", that lets us insert a table into the NewMenu table and overwrite some values</p> <p>Example :</p> <pre><code>function base:Test()\n    local characterMenuTable = {}\n    characterMenuTable.Normal = {\n        [\"TEST\"] = {\n            [\"#TAGS\"] = { \"IGNORE\" },\n            Name = \"test\",\n            CharacterSprite = CharacterMenu:GetCharacterPortraitSprite(),\n            SheetSprite = \"gfx/ui/main menu/charactermenu.anm2\", true),\n            IsUnlocked = function(self)\n                return 1\n            end,\n            MenuType = \"Normal\"\n        }\n\n    }\n    return characterMenuTable\nend\n\nYourMod:AddCallback(\"MenuReimagined_GetCharacterMenu\", base.Test)\n</code></pre> <p>This one makes the TEST character in the Normal menu to be IGNORED (in #TAGS) from the menu. The IsUnlocked allows us to make a function that return 1 if its unlocked, -1if is hidden and 0 if its locked, and MenuType says in what menu it belongs, needed to check the sheet bg for rendering if not given one</p> <p>The NewCharacterSheet model is like follows:</p> <pre><code>--Includes Character Sprite and Is Unlocked, defaults to normal bg and the rest. Marks are manually handled\n---@class NewCharacterSheet @Each new character Menu\n---@field [\"#TAGS\"]?       table&lt;CharacterTags&gt;\n---@field Id               PlayerType|number\n---@field Name?             string\n---@field CharacterSprite   Sprite\n---@field IsUnlocked        function\n---@field SheetSprite?      Sprite\n---@field Background?        Sprite\n---@field MenuCode?         function\n---@field MenuType         string\n---@field Position?         number\n</code></pre> <p>Current #tags are: - \"IGNORE\" : Ignore the character in the menu. - \"INVISIBLE\" : If it shouldn't be aded if not unlocked, deprecated, please use IsUnlocked returning -1 for that. - \"EDENVARIANT\" = If it uses tokens as eden to be played as.</p>"},{"location":"Menu%20Reimagined/#custom-charactermenutype","title":"Custom CharacterMenuType","text":"<p>In the same callback, you can also return a non existent CharacterMenuType, such as Tarnished (Epyphany) to create it ALso, we add the \"BGSpriteSheet\" with the string of the png with the menu variant sheet</p> <p>Example for Epyphany:</p> <pre><code>function base:Epiphany()\n    if not Epiphany then return end\n\n    ---@type table&lt;string,table&lt;string,NewCharacterSheet&gt;&gt;\n    local characterMenuTable = {}\n    characterMenuTable.Normal = {\n        [\"[TECHNICAL] C-Side Detect\"] = {\n            [\"#TAGS\"] = { \"IGNORE\" }\n        },\n    }\n    characterMenuTable.Tarnished = {\n        [\"BGSpriteSheet\"] = \"gfx/ui/main menu/poster alt.png\",\n        [\"[TECHNICAL] C-Side Detect\"] = {\n            ---@diagnostic disable-next-line: assign-type-mismatch\n            CharacterSprite = Sprite(\"gfx/ui/main menu/MenuReimagined/OOIIA.anm2\", true),\n            --SheetSprite = , --\"gfx/ui/main menu/charactermenu.anm2\", true),\n            Id = Isaac.GetPlayerTypeByName(\"[TECHNICAL] C-Side Detect\"),\n            IsUnlocked = function()\n                return 1\n            end,\n            MenuType = \"Tarnished\",\n        }\n    }\n    characterMenuTable.Tarnished[\"[TECHNICAL] C-Side Detect\"].CharacterSprite:Play(characterMenuTable.Tarnished\n        [\"[TECHNICAL] C-Side Detect\"].CharacterSprite:GetDefaultAnimation())\n    return characterMenuTable\nend\n\nYourMod:AddCallback(\"MenuReimagined_GetCharacterMenu\", base.Epiphany)\n</code></pre> <p>This example makes the default Door to be Ignored, and creates it into the new Tarnished type</p>"},{"location":"Menu%20Reimagined/#menu-code","title":"Menu Code","text":"<p>If you need to run something only when the character is selected, for any reason, there is now a callback to do that. The modded callback \"MenuReimagined_MenuCode\" runs every time it renders and the character is selected, with the arguments of characterId.</p> <p>Example:</p> <pre><code>function base:TestMenuCode(id)\n    if id == PlayerType.PLAYER_CAIN then\n        local tokens = Isaac.GetPersistentGameData():GetEventCounter(EventCounter.EDEN_TOKENS) .. \" Tokens\"\n        local mouse = Isaac.WorldToScreen(Input.GetMousePosition(true))\n        local a = Isaac.WorldToMenuPosition(MainMenuType.CHARACTER, Vector.Zero)\n        --Font previously loaded\n        YourMod.Font.Meat16:DrawString(tokens, mouse.X, mouse.Y,\n            KColor(0.212, 0.184, 0.176, 1))\n    end\nend\n\nYourMod:AddCallback(\"MenuReimagined_MenuCode\", base.TestMenuCode)\n</code></pre> <p>This example renders the eden tokens when the character Cain is selected at the mouse position</p>"},{"location":"Menu%20Reimagined/#animated-character-portraits","title":"Animated Character Portraits","text":""},{"location":"Menu%20Reimagined/#locked-portraits-and-animations","title":"Locked Portraits and Animations","text":"<pre><code>Currently, there are implemented 4 animations for animated portraits, \nwith support for variants for locked ones, these are aswell the Status.\nNames are CASE SENSITIVE.\n</code></pre> <ul> <li>\"OnSelect\"</li> <li>\"Selected\"</li> <li>\"OnUnselect\"</li> <li>\"UnSelected\"</li> <li>\"LockedOnSelect\"</li> <li>\"LockedSelected\"</li> <li>\"LockedOnUnselect\"</li> <li>\"LockedUnSelected\"</li> </ul>"},{"location":"Menu%20Reimagined/#basic-behaviour","title":"Basic Behaviour","text":"<p>Portraits will be animated as UnSelected or LockedUnSelected depending on their lock state, and will change animations accordingly to the character Carousel status. - OnSelect and LockedOnSelect triggers when a character is selected as the next selected character. - OnUnselect and LockedOnUnselect will trigger for the selected character when the next selectedCharacter isn't itself. The rest will play repeatedly.</p>"},{"location":"Menu%20Reimagined/#idles-implementation","title":"Idles implementation","text":"<p>If you have an animation named Idle, it will run the Idle proces when replaying the \"Selected\" animation (currently only unlocked Idles are supported). This process will do:</p> <ul> <li>Gets All animations that INCLUDE \"Idle\" on their name as the first part</li> <li>Store them in a table </li> <li>Select one of them at randomly if a 5% RNG triggers and plays it. (Custom sfx support not implemented yet) </li> </ul>"},{"location":"Menu%20Reimagined/#carouselrender-callback","title":"CarouselRender Callback","text":"<p>With the custom Callback \"MenuReimagined_CarouselRender\", you can run a function that has the arguments CharacterId, CharacterSprite, status, and return a boolean, if the return is true, the custom management by the api is ignored in favour of yours.</p>"},{"location":"Menu%20Reimagined/#custom-main-menu-types","title":"Custom Main Menu Types","text":"<p>For the new seed input menu, I've tweaked the MenuManager a bit, now with support for custom MainMenuTypes and a new way to SetViewPos withouth constantly setting it forcefully.</p>"},{"location":"Menu%20Reimagined/#new-menumanager-functions","title":"New MenuManager Functions","text":"<ul> <li>NewGetActiveMenu: returns the normal GetActiveMenu or the custom MainMenuType (string) that is currently set.</li> <li>NewSetActiveMenu: Accepts both MainMenuType and string, if setting a vanilla menu, it removes any SetViewPosition.</li> <li>NewSetViewPosition: Has Arguments position(vector) and isForced(boolean). If isForced we keep the view set to that position. The positionis given in Menu coordinates</li> <li>NewGetViewPosition: Returns the custom ViewPos in MenuCoords, or the GetViewPosition if not overriden.</li> </ul> <p>The api uses this helper function to transform Menu coords to Screen Coords and viceverse:</p> <pre><code>---Get Screen coords from menu vector\n---@param vectorPos Vector\n---@return Vector\nfunction helper:MenuToScreenPosition(vectorPos)\n  return -vectorPos + Vector(Isaac.GetScreenWidth() / 2, Isaac.GetScreenHeight() / 2)\nend\n</code></pre>"},{"location":"Menu%20Reimagined/#how-to-set-a-new-mainmenutype","title":"How to set a new MainMenuType","text":"<p>To set a new custom menu type, we use NewSetActiveMenu(stringOfCustomMenu) and then NewSetViewPosition(NewMenuPosition) to set the view</p> <pre><code>MenuManager.NewSetActiveMenu(\"SeedsMenu\")\nMenuManager.NewSetViewPosition(Vector(760, 945), true)\n</code></pre> <p>This will make NewGetActiveMenu return the custom menu we just set.</p>"},{"location":"Menu%20Reimagined/#custom-callback-onmoddedmenuupdate","title":"Custom callback OnModdedMenuUpdate","text":"<p>The custom callback \"MenuReimagined_OnModdedMenuUpdate\" runs ONCE when we change MainMenuTypes, both between vanilla and Modded types, it allows us to set the input mask to whichever we want ONCE</p> <p>Example:</p> <pre><code>function base:OnModdedMenuUpdate(curMenu, prevMenu)\n    if prevMenu == MainMenuType.CHARACTER and type(curMenu) == \"number\" then\n        print(\"Bit vanilla\")\n        MenuManager.SetInputMask(4294967295)\n    elseif curMenu == MainMenuType.CHARACTER then\n        print(\"Bit Character\")\n        MenuManager.SetInputMask(base.Bitwise.CharacterMenu)\n    elseif curMenu == \"SeedsMenu\" then\n        print(\"Bit Seeds\")\n        MenuManager.SetInputMask(base.Bitwise.SeedMenu)\n    end\nend\n\nYourMod:AddCallback(\"MenuReimagined_OnModdedMenuUpdate\", base.OnModdedMenuUpdate)\n</code></pre> <p>This function will change the inputmask when changin menus, and is the default in this API</p>"},{"location":"Menu%20Reimagined/Characters%20Menu/","title":"Characters Menu","text":""},{"location":"Menu%20Reimagined/Characters%20Menu/#menu-character","title":"Menu Character","text":"<p>Main focus of the mod, I've reimplemented the Character menu completely, ~~mostly~~.</p> <p>With the current progress, you can CREATE your own characters Tab/CharacterMenuType, so you can add any C-side/ N-side or pack of characters as a modded Tab.</p> <p>Currently working in reimplementing the seed menu, with a 60% seed input done.</p>"}]}